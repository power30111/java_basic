#반복문 for each
For Loop(향상된 루프) java5에서 처음나왔고, int i=0; 꼴이나 배열의 크기를 입력하지않아도 됨.(파이썬마냥)
즉 for(int i=0; i<array.length; i++) 또는 for(int mark:marks)
단 앞에서 for()문의 인자로 주어지는 mark는 marks의 자료형 형태에 따라 바꿔야한다. 즉 marks가 int형이면 int mark.
marks가 Object형이면 Object mark, ex)String[] number ={"one","two","three"} -> for(String num:number)
즉 for(type var: iterate)의 꼴로 선언해야한다. ArrayList의 경우도 동일하게 한다
ex) ArrayList<String> numbers = new ArrayList<>(ArrayList.asList("One","Two","Three"));
-> for(String number : numbers)
주의할점은 반복횟수를 명시적으로 주는것이 불가능하며, 1스텝씩 차례대로 반복할경우에만 적합하다.

#Array
Array을 선언하고 초기화했을떄 -> ex) int [] Array = new int[5]; //Array라는 int형 배열을 선언하였는데, 크기가 5이다(변경할수없다)
이때 Array내부의 원소는 [0,0,0,0,0]이다. 이부분을 다른 수로 채우고싶을땐 Arrays.fill(Array,N)을 하면 N으로 채워진다.

#비교연산자와 Equals()메서드의 차이.
equals()메소드는 비교하고자 하는 두개의 대상의 값 자체를 비교
==연산자는 비교하고자 하는 두개의 대상의 주소값을 비교

#정렬 sort
Arrays.sort(array);
Collections.sort(array);        --> 대개 사용.

#변수의 최대값 최소값을 모를떄
Integer.Max_VALUE 와 Integer.Min_VALUE 사용하면됨.

#최대값과 최소값 찾기 (Max,Min)
-> Collections.Max(), Collections.Min()

#소수점관련해서 돈이나,정확한 계산이 필요한 나눗셈의 경우
float, double 이 아닌 BigDecimal 을 써야한다. BigDecimal은 new BigDecimal(변수)로 객체를 생성할수있다.
BigDecimal.divide()메서드를 사용하여 정확히 나눌수있다. ex) BigDecimal(A).divide(new BigDecimal(B));
여기서 옵션이 더있는데 알아둬야할 옵션은 두가지.
Precision -> 정확도 (소수점 몇자리까지 표시?)
Rounding mode -> 반올림(반올림 할까?)
적용해서 예시를 들어보면 BigDecimal(A).divide(new BigDecimal(B),3,RoundingMode.UP); //3번쨰 소수점자리까지 표시하고 반올림

#메서드에 다양한 숫자의 argument를 입력하고싶은경우 (가변인수, 인자 여러개)
ex) void print(int... values) 로 나타낼수있다. 배열로 입력되는것같다.
단. 가변인수는 모든 인자들중 맨뒤에 와야한다. ex) void print(int ... values, String name) -> error

#클래스를 출력할떄 출력형식을 변경할수있다.
ex) public String toString(){return ...} 이후
System.out.println(class) 이렇게 호출하면 ...에 해당하는 내용이 출력된다. 보통 String toString은 맨 마지막에 위치한다.(관례?)

#클래스 구조와 관련하여..
class 내부 구조는 크게 3가지로 구분될수있다. 1.state(상태) 2.constructors(생성자) 3.behavior(행위)
state 는 말그대로 그 class 객체에 어떤 상태인지 알려주는 것.
constructors 는 state를 선언하는 과정에서 객체를 생성하지말고 [ ex) private int speed = new speed(13);] 생성자를 통해 한다.
이는 싱글톤패턴과도 관련이 있다.
behavior는 이 객체가 어떤것을 할수있는지에 대해서 메서드로 나타낸다고 생각해두자.

#Static
static 키워드를 붙이게 되면 자바는 메모리 할당을 딱 한번만 하게된다. 즉 static을 붙인 변수든 클래스든간에 싱글톤 패턴을 사용한다.
static 키워드를 붙인 메서드의 경우 객체 생성없이 클래스를 통해 메서드를 직접 호출할수있다.

#String.format()
ex) ("My name is %s, i'm %d years old.",name,year);
name = String , year = int

#자료형
byte = 정수형중 가장 작은 범위를 가진 정수형으로써 8bit (256개의 숫자)
short = 2 byte
int = 4byte
long = 8byte

#상속 extends
level2_inheritance package를 참고. 다중상속은 지원하지않는다.(c++에서는 가능) 단 상속계층(상속이 꼬리를 무는느낌)은 가능.
ex) Person 이란 class가 있다면.
    public class Student extends Person --> Person에 있는 것들을 모두 사용가능하다. 또한 다른기능들을 추가가능하다.
    Person class => super class, Student class => sub class;
여기에 추가적으로 아무것도 상속받지않는 class 는 기본적으로 Object를 상속받는다. 여기서 기본적인 class의 기능들을 상속받는다.
결국 모든 class는 상속받는 관계이다.

#Override
상위 클래스에서 제공되는 적용법을 덮어쓰고 싶을때 사용.

#상위클래스에 접근하고싶다면 super. 메서드를 사용하여 접근할수있다.
하위 클래스에서의 생성자에서는 항상 상위클래스의 생성자를 호출한다. [super()을 쓰든 안쓰든 자동적으로 컴파일러에서 적용함]
상위 클래스에서 생성자를 만들게되면 하위 클래스에서는 컴파일러 에러가 뜨는데, 해결하기 위한 방법은 2가지다.
1. public superClass(){}와 public superClass(인자들){} 이렇게 두가지 경우의 생성자를 만든다(인자가 없을경우와 있을경우)
2. 하위 클래스에서 super(필요한 인자); 를 호출하기.///예시는 level2_inheritance package 의 Person(superClass)와 Student(subClass)참고
즉 하위 클래스에서는 무조건 상위클래스의 생성자가 정의되어야한다.

#추상 클래스 AbstractClass
abstract class className{} 으로 class 앞에 abstract를 붙여서 만든다. 추상메서드 = 정의도 없고 형태도 없는 메소드(이름만있음..)
추상 메서드도 abstract public void ade(); 로 선언한다. 여기서 메서드가 하는일이 적혀있지않는데 이것은 어떻게 해결하는가?
-> 추상 클래스를 상속받는 하위 클래스에서 추상 클래스를 다시선언하여 정의와 형태를 만들어준다. ex)AbstractClassCreate pakage 참고
추상 클래스의 인스턴스는 만들어질수없다. 

#인터페이스 Interface
Interface는 추상 클래스처럼 미리 정의도 없고 형태도 없는 메소드를 선언한다. 또한 이 인터페이스를 구현하는 하위클래스는 implements UpperClass 로 선언해야만 한다.
또한 하위클래스에서는 상위클래스에서 선언한 메서드들을 @Override 어노테이션을 사용한채로 다시 재정의 해야한다. ex)InterBasic package 참고
즉 인터페이스에는 일단 구현해야하는 기능들을 간단하게 사용할 임시구현클래스를 만들고 사용하다가 진짜 사용해야할때 제대로된 구현 클래스를 만들어서
사용해야 할때 유용하다.[실제로 사용 가능하지 않더라도 작업을 계속할수있게끔 하거나 Test코드에서 유용할듯 싶다.
(가장 큰 특징은 코드변경을 최소화 하면서 동작하는 방식을 변경해줄수있다. Spring에서 사용하는걸 본적있음.)
인터페이스는 인터페이스를 extends 할수있다. 단 인터페이스를 연장시킨 인터페이스2를 구현(implement)하기 위해서는 인터페이스 1과 인터페이스2의
추상메서드 들을 구현해야한다. 여기서 인터페이스2에 해당하는 메서드들만 구현해서 사용하고 싶다면 추상클래스를 구현클래스로써 사용하면된다.
추상클래스에서는 인터페이스에 선언되어있는 메서드들의 일부만 구현할 수 있도록 허용되어있다. (근데 이 추상클래스를 구현하는 클래스는 죄다 구현해야함..)
인터페이스에서는 변수는 선언할수없고(int test;) 상수는 선언할수있다.(int test =5;)
추상적인 메서드를 선언하는것 뿐만 아니라 구현까지 마친 일반적인 메서드들을 만들수도있다.(Java 8에서 허용된..)

#추상클래스와 인터페이스 차이?
추상클래스와 인터페이스는 하는일이 비슷해 보이나 존재목적이 좀 다르다고 할수있다.
아니, 추상적으로 메서드들을 적어놓고 하위클래스에 구현(@Override)을 맡기는 부분이 아주 하는일이 같아보이는데 뭐가 다른걸까?
일단 추상클래스는 일부분만 구현해도 일단은 돌아가는데, 인터페이스의 경우에는 모두 구현해야 동작한다.
또한 추상클래스는 다중상속이 불가능한데, 인터페이스의 경우에는 다중상속이 가능하다.(그만큼 구현도 다해줘야한다)
추상클래스는 상속에 대한 계층구조를 명확하게하고, 일반변수들과 일반 메서드들을 사용가능하며 구현하지 않아도 될 메서드는 냅둬도 괜찮다.
인터페이스는 디자인(내부적으로 동작하는 부분)이 자주 바뀌거나 메서드 형태만 서로 공유해서 구현되는 상황일 떄 적합하다.
인터페이스가 자주 사용되는이유는 동시개발이 가능하다는 점 때문이다(대충만든 구현클래스만 만들어도 동작이 가능하기떄문)
추상 클래스 = 관련선이 높은 클래스들 간에 코드를 공유하고싶은경우 (상속 관계),추상 클래스를 상속 받을 클래스들이 공통으로 가지는 메소드와
필드가 많거나 public 이외의 접근제어자가 필요한경우.
인터페이스  = 서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는경우(비슷한 동작을 하는 메서드가 필요한경우)
특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동들이 구현되는지 신경쓰지 않아도 되는경우, 다중상속을 허용하고 싶은경우.
//InterBasic 의 FlyRunner 와 AbstractClassCreate 의 AnimalRunner 참고할것.
//참고 https://velog.io/@new_wisdom/Java-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4

#객체 생성?
자바에서 객체를 생성할 때 선언하는 기준은 해당 클래스의 생성자를 호출하고, 반환된 인스턴스를 변수에 할당하는 방식이다.
ex) Person person = new Person("Alice",24); 이라고 한다면 new Person("Alice", 24) 는 Person클래스의 생성자를 호출하고
"Alice"와 24를 인자로써 전달하여 Person객체를 생성한다. 그리고 이 객체를 person 변수에 할당한다.

#접근제어자 private public default protected
public => 접근에 제한이 없음
protected => 동일한 패키지 내에 존재하거나 파생클래스에서만 접근 가능
default => 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근이 가능
private => 자기 자신의 클래스 내에서만 접근이 가능
접근 범위의 크기순 public > protected > default > private

#프로그래머가 알아야할 97가지
https://choiwy.tistory.com/477

#다형성
같은 코드로 동작하는데 다른 방식으로 결과가 나온다.=> 추상클래스 ( 각 객체의 참조값에 따라 변화한다)

#불변성과 가변성
문자열, BigDecimal, Wrapper 등은 인스턴스를 만든 순간부터 값을 변경할수없다. 만일 List를 가변성 배열로써 사용하고싶다면
ArrayList, LinkedList, Vector 등을 사용해야한다. 이미 만들어진 List의 원소들로 ArrayList를 만들려면 어떻게해야할까?
-> List<String> ArrayListTest = new ArrayList<>(List); -> List<String> LinkedListTest = new LinkedList<>(List);
이러한 ArrayList등은 원소를 추가할수있다.

#집합 Collections (Java 9 부터 지원)
1.List 2.Set 3.Queue 4.Map 기본적으로 .of 메서드를 통해 만든것들은 죄다 불변이다.
초기화방법 List<String> words = List.of("Apple","Bat","Cat");
자주 사용되는 메서드 size() = list크기 반환, isEmpty() = 비어있는지 확인, get(n) = n번째 인덱스 의 원소 반환,
 contatins(A) = A라는 원소가 있는지 boolean 으로 반환, indexof(A) = A라는 원소가 몇번째 원소에 있는지 반환,존재하지않을경우 -1 반환
 #instanceof 현재 객체가 특정 클래스의 인스턴스인지 알 수 있게 해준다.
 ex) Class instanceof Object --> true  ,  Object instanceof Class --> false

#ArrayList 배열
가변리스트이다 .add()메서드, .remove()메서드로 삽입또는 지울수있다. 자세한건 검색.
선언하는 건 ArrayList items = new ArrayList(); 로 할수있는데, 여기서 제네릭(자바5에서 나온 기능)을 사용해야한다.
즉 어떤 자료형을 ArrayList에 담을건지 명시해야한다는 뜻이다. ex) ArrayList<String> items = new ArrayList<String>();

#LinkedList
한요소에서 다른요소로의 참조가 들어있는 방식의 배열. 어떠한 원소하나에 접근하는것은 느릴수있으나 배열의 일부분을 변경할경우에는 빠른속도를 보장한다.
ArrayList와 Vector는 기본적으로 Array방식으로 동작하지만, LinkedList는 자신만의 방식이있다. LinkedList의 특정원소는 자기 앞과 뒤의 원소로 갈수있다.
즉 ArrayList와 Vector는 원소의 변경에는 시간이 많이들지만 특정원소에 접근하는것은 빠르다.
LinkedList는 원소의 변경에는 시간이 빠르지만 특정원소에 접근하는것은 느리다.

#Vector
여러 쓰레드가 동작하고있을경우 Vector는 거의 모든 메서드들이 Synchronized(동기화) 되어있기때문에 안전하다.
가장 기본적인 동기화를 제공한다.ArrayList는 Thread Safe를 보장하지않는다.

#Generic 제네릭
대충 List<여기> items = List.of(); 라고 하였을때 <> 여기 안쪽에 자료형을 넣어주면 그 변수는 넣어준 자료형만 담을수있게된다.
또한 List는 안에 원소들을 담을때 Rapper 클래스에 해당하는 자료형들로 넣어지게된다.(Auto Boxing) ex) int 1 -> Integer 1
<>안에는 따로 만든 객체들도 넣을수있다. (CollectionsBasic 의 StrudentSort와 StudentRunner참고)
<T> =>Type의 앞글자로써 어떤 타입이든 사용가능하다. 더 넓은 의미로 확장하고싶다면 <TYPE>으로 할수있다.모두 대문자여야한다.
만일 <T extends Number> 이라고 한다면 Number를 상속하는 정수계열(Integer,Long,int 등등)에 한해서 자료형사용이 가능하도록 할수있다.
이러한 형태의 종류에 대한 제한을 거는 제네릭이 가장 흔히 사용되는 제네릭이다. generics package의 MyCustomList 참고
또한 메서드에 제네릭을 거는 것 또한 흔히 사용한다고 한다. generics package 의 GenericRunner참고
<T> = Type / <E> = Element / <K> = Key / <V> = Value / <N> = Number

#iterator 객체.
생성방법 => Iterator<데이터 타입> iterator이름 = 컬렉션.iterator();
Iterator는 모든 Collections 프레임워크에서 공통으로 사용가능하고, 쉽게 값을 가져오고 제거할수있으며, 주요3가지 메서드만 알면 사용하기쉽다.
Iterator.hasNext() = Iterator안에 다음값이 들어있는지 확인 bool로 반환, Iterator.next() => Iterator의 다음값 가져오기
Iterator.remove() = Iterator에서 next()로 가져온 값을 컬렉션에서 삭제. 반드시 next()다음에 사용해야한다.
Iterator는 처음부터 끝까지 단방향으로만 반복이 가능하고, 값을 변경 및 추가가 불가능하며, 대량의 데이터를 제어할때 속도가 느리다.
예시 사용방식 ex) Iterator wordsIterator = wordArrayList.iterator();
                    while(wordsIterator.hasNext()){
                        System.out.println(wordsIterator.next());
                    }                   CollectionsBasic package의 CollectionArrayList 참고.

#Compare Comparable 비교자
Collections.sort()에서 sort()의 정의를 보니 Comparable 인터페이스를 구현한 객체에서만 동작하도록 되어있었다.
Generic<> 을 통해 내가 원하는 객체형식으로 List를 만들었는데 어떻게하면 Sort()를 사용하여 정렬할수있을까? <>안에 정의된 객체에서
Comparable을 상속받아 구현해주면된다. CollectionsBasic package의 StudentSort 를 참고해보자.
comparable을 상속받아서 직접 구현해주는데, StudentSort 끼리의 비교를 하고싶기때문에 상속받을떄 <> 을 사용하였다.
Integer.compare()함수에서는 this.id => 현재 객체 that.id => 비교하려는 객체이다.
this.id 가 클경우 1 작을경우 -1 같을경우 0

#Set
2-1)중복이 허용되지않는다. 위치접근을 제공하지 않는다. 순서가 보장되지않는다.불변이다. Set<String> set = Set.of("Apple","Banana","Cat");
2-2)Set의 여러구현중 Hashset이 대표적이다. ex)Set은 add메서드를 제공하지않는다.Hashset은 제공하나 중복이있을경우 false를 반환한다.
2-3)Hashset = 순서보장 x 중복허용 x /LinkedHashset = 삽입순서보장 o 중복허용 x /TreeSet = 크기순으로 정렬된 순서보장 o 중복허용 x
 CollectionsBasic CollectionHashSet 와 CollectionSetRunner 참고

#Hashing HashTable Hash
Hashing Function은 기본적으로 값%테이블크기 로써 인덱스가 주어진다. 예시로 0~12의 크기를 가진 HashTable이 있다고 하자.
그렇다면 13의값을 가진 원소는 0번째 인덱스에 (13%13=0) 넣어지게되고, 15의 값을 가진 원소는 (15%13=2) 2번째 인덱스에 들어간다.
6,45,58과 같이 (6%13=6),(45%13=6),(58%13=6) 처럼 중복되는경우 에는 같은 인덱스에 담는다.
이런식의 나머지를 이용한 Hashtable 은 일종의 예시이며 다양한 종류로 만들수있다.(Hash Function)
HashTable은 요소들을 변경할수있고, 검색이 빠르다.(LinkedList보단 삽입과 제거가 느릴순있지만 배열보다 빠르다)

#Tree
삽입과 제거, 검색이 빠르다. NavigableSet 인터페이스도 구현한다.(다른 컬렉션 인터페이스에서는 없는 기능들을 제공)
여러 메서드들이 있는데 CollectionsBasic package의 CollectionTreeSet 참고

#Queue
선입선출

#PriorityQueue 우선순위 큐
기본적으로 사용자가 정의한대로 정렬되어있다. 이런곳에 넣는 인자는 Comparator를 받는게 이미있네.. 여기에 내가 원하는 비교기준을
Compare인터페이스를 상속받아서 구현한 구현클래스를 넣어주게되면 그거에 맞춰서 객체가 만들어지는구나.
CollectionsBasic package 의 CollectionQueue 참고

#Map
Collection 인터페이스를 구현하지않는다... 그러므로 Collection인터페이스에서 제공하던 기능들을 사용할수없다.ex)add..
기본적으로 Key= Value 꼴을 하고있다. 당연하게도 key값은 중복되지않겟지요
Map을 구현하는 것들로는 HashMap, Hashtable, LinkedHashMap, TreeMap 이있다.

#HashMap
내부에서 순서가 보장되지않고 분류또한 되어있지 않다. key=null값을 저장할수있다.

#Hashtable
HashMap과 비슷하지만 Vector 처럼 모든 메서드가 동기화되어있기 때문에 쓰레드관련해서 안전하다.
key=null값을 저장할수없다.

#LinkedHashMap
삽입순서가 보장되고 정렬x HashMap에 비해 삽입과 제거가 조금 느리다. 하지만 요소끼리 연결되어있어서 요소들을 도는 iteration은 빠르다.

#TreeMap
기반 데이터 구조는 Tree이므로 정렬된 순서를 보장한다. 또한 데이터가 정렬되어있기때문에 다른 인터페이스도 구현하는데
TreeSet과 비슷하게 NavigableMap을 구현하여 다른 기능들이 추가적으로 존재한다.
CollectionsBasic package의 ColelctionTreeMap 참고.

#와일드카드 ?
일단 generics package의 GenericRunner를 보자.
List<? extends Number>list -> 상한 경계 와일드카드          List<? upper Nummber>list -> 하한 경계 와일드카드
상한 경계 와일드카드는 Number의 하위클래스인 모든 리스트들에 대해 공통된 논리를 구현하는데 도움을 준다.
하한 경계 와일드카드는 Number의 하위클래스인 여러 다른값들이 추가 될수 있게 도움을 준다.

#Stream 스트림
선언으로는 IntStream(), StringStream()등 여러가지 자료형에 따라 Stream 메서드가 제공됨
1. 스트림은 외부 반복을 통해 작업하는 컬렉션과는 달리 내부 반복(internal iteration)을 통해 작업을 수행합니다.
2. 스트림은 재사용이 가능한 컬렉션과는 달리 단 한 번만 사용할 수 있습니다.
3. 스트림은 원본 데이터를 변경하지 않습니다.
4. 스트림의 연산은 필터-맵(filter-map) 기반의 API를 사용하여 지연(lazy) 연산을 통해 성능을 최적화합니다.
5. 스트림은 parallelStream() 메소드를 통한 손쉬운 병렬 처리를 지원합니다.
기본적으로 lamda 식을 사용한다. 스트림은 중간 연산과 종단 연산이 있다.
중간 연산 => .filter(),map(),sort()등 스트림을 사용자가 원하는 또다른 요소 스트림으로 나오게 하는것들.
종단 연산 => .reduce(),forEach()등 스트림 요소 전체를 소모하거나 하나의 값만 return한다. ex)최소 요소찾기, 최대 요소찾기, 총합찾기, 각요소 소모하기(forEach())
forEach()메서드는 stream에서 요소를 하나씩 반복하는 메서드.                //종단 연산
filter()메서드는 안에서 선언한 조건에 맞을경우에만 요소를 넘기는 메서드.        //중간 연산
sorted()메서드는 정렬메서드.     //중간 연산
distinct()메서드는 중복제거 메서드 //중간 연산
map()메서드는 원하는 함수를 적용시키기 위한 중간 연산?같은느낌(각요소에 함수를 적용시킨다는 느낌으로 파이썬의 map()과 동일한것같다.) //중간 연산
max()메서드는 최대값을 구하는 메서드인데, 최대값을 구하기 위해서 compare(비교자)를 구현해야한다.  //종단연산  //Functional Package에서 FPTest 참고
ex)List.of(23,12,34,53).stream().max((n1,n2) -> Integer.compare(n1,n2)); 또한 Null값이 나오는것을 방지하기위해 Optional 을 import해줘야한다...
min()메서드는 최소값을 구하는 메서드이다. max()와 같이 compare을 구현해줘야한다.  //종단연산
collect()메서드는 요소들을 모아서 컬렉션으로 담을수있게끔 해준다 //종단연산
boxed()메서드는 IntStream과 같이 원시 타입에 대한 스트림지원을 클래스타입으로 전환하여 사용하기위함 ex)IntStream의 경우 collect()메서드를 적용할수없음.
즉 primitive(원시타입) -> Wrapper타입으로 반환.

#lambda Expression 람다표현식?
함수형 인터페이스에 기반을 두고 작동한다.
가장 중요하다는 filter(), map(), forEach()에서 람다식이 어떤식으로 내부적으로 동작하는지.
Functional package의 LambdaRunner, MethodReferencesRunner 참고.
lambda표현식을 메서드 참조로 변환할수있다.

#Method reference 메서드 참조
람다 표현식을 더 간단하게 (클래스명 :: 메서드)로 표현할수있다.

#Optional
Type의 일종으로 Null(정확히는 Null pointer exception 에러)이 나오는 상황을 최대한 줄이기 위해 도입 (Java 8부터)
만일 반환값이 없는경우 Null이 아닌 optional.empty를 반환한다. stream은 Optional의 값을 반환하게 하는게 좋다.
//Functional package의 WhatOptional 참고 여러 메서드들이 있는데 자세한건 검색
isPresent() 값이 있는지에 대해 true false
orElse() 값이 비어있다면 ()안의 값 반환

#Predicate
//일단 filter() 사용하면 자바 컴파일러가 함수형 인터페이스를 실행하는데, 함수형 인터페이스에서 가장 중요한것은 Predicate처럼
//하나의 메서드만 정의되지 않는다느것이다. 기본적으로 람다형을 생성할때 특정메소드를 실행해주는 작업을 한다.
//정리하자면 filter()에서 실행되지않는 유일한 메소드를 불러와서 test메소드가 실행되게 한다.
//Predicate라고 불리는이유는 하는 작업이 평가를 진행한뒤 참인지 거짓인지 판단하여 그 값을 반환하기 떄문이다.
//즉 Predicate 인터페이스는 test를 통과했는지 아닌지에 대한 값을 반환한다.

#Functional programming 함수형 프로그래밍?
가장먼저 변화화는 값을 가지지 않아도 코드를 작성하게할수있다.ex) for문과 stream()
1.변수에 함수를 넣을수있다.
2.메서드로부터 반환받는게 함수일수있다.
3.메서드에 함수를 넣어서 전달할수있다(인자로 넣는 것)
Functional package의 functionalProgrammingRunner, FPNumberRunner