#반복문 for each
For Loop(향상된 루프) java5에서 처음나왔고, int i=0; 꼴이나 배열의 크기를 입력하지않아도 됨.(파이썬마냥)
즉 for(int i=0; i<array.length; i++) 또는 for(int mark:marks)
단 앞에서 for()문의 인자로 주어지는 mark는 marks의 자료형 형태에 따라 바꿔야한다. 즉 marks가 int형이면 int mark.
marks가 Object형이면 Object mark, ex)String[] number ={"one","two","three"} -> for(String num:number)
즉 for(type var: iterate)의 꼴로 선언해야한다. ArrayList의 경우도 동일하게 한다
ex) ArrayList<String> numbers = new ArrayList<>(ArrayList.asList("One","Two","Three"));
-> for(String number : numbers)
주의할점은 반복횟수를 명시적으로 주는것이 불가능하며, 1스텝씩 차례대로 반복할경우에만 적합하다.

#Array
Array을 선언하고 초기화했을떄 -> ex) int [] Array = new int[5]; //Array라는 int형 배열을 선언하였는데, 크기가 5이다(변경할수없다)
이때 Array내부의 원소는 [0,0,0,0,0]이다. 이부분을 다른 수로 채우고싶을땐 Arrays.fill(Array,N)을 하면 N으로 채워진다.

#비교연산자와 Equals()메서드의 차이.
equals()메소드는 비교하고자 하는 두개의 대상의 값 자체를 비교
==연산자는 비교하고자 하는 두개의 대상의 주소값을 비교

#정렬 ?
Arrays.sort(array)

#변수의 최대값 최소값을 모를떄
Integer.Max_VALUE 와 Integer.Min_VALUE 사용하면됨.

#최대값과 최소값 찾기 (Max,Min)
-> Collections.Max(), Collections.Min()

#소수점관련해서 돈이나,정확한 계산이 필요한 나눗셈의 경우
float, double 이 아닌 BigDecimal 을 써야한다. BigDecimal은 new BigDecimal(변수)로 객체를 생성할수있다.
BigDecimal.divide()메서드를 사용하여 정확히 나눌수있다. ex) BigDecimal(A).divide(new BigDecimal(B));
여기서 옵션이 더있는데 알아둬야할 옵션은 두가지.
Precision -> 정확도 (소수점 몇자리까지 표시?)
Rounding mode -> 반올림(반올림 할까?)
적용해서 예시를 들어보면 BigDecimal(A).divide(new BigDecimal(B),3,RoundingMode.UP); //3번쨰 소수점자리까지 표시하고 반올림

#메서드에 다양한 숫자의 argument를 입력하고싶은경우 (가변인수, 인자 여러개)
ex) void print(int... values) 로 나타낼수있다. 배열로 입력되는것같다.
단. 가변인수는 모든 인자들중 맨뒤에 와야한다. ex) void print(int ... values, String name) -> error

#클래스를 출력할떄 출력형식을 변경할수있다.
ex) public String toString(){return ...} 이후
System.out.println(class) 이렇게 호출하면 ...에 해당하는 내용이 출력된다. 보통 String toString은 맨 마지막에 위치한다.(관례?)

#클래스 구조와 관련하여..
class 내부 구조는 크게 3가지로 구분될수있다. 1.state(상태) 2.constructors(생성자) 3.behavior(행위)
state 는 말그대로 그 class 객체에 어떤 상태인지 알려주는 것.
constructors 는 state를 선언하는 과정에서 객체를 생성하지말고 [ ex) private int speed = new speed(13);] 생성자를 통해 한다.
이는 싱글톤패턴과도 관련이 있다.
behavior는 이 객체가 어떤것을 할수있는지에 대해서 메서드로 나타낸다고 생각해두자.

#Static
static 키워드를 붙이게 되면 자바는 메모리 할당을 딱 한번만 하게된다. 즉 static을 붙인 변수든 클래스든간에 싱글톤 패턴을 사용한다.
static 키워드를 붙인 메서드의 경우 객체 생성없이 클래스를 통해 메서드를 직접 호출할수있다.

#String.format()
ex) ("My name is %s, i'm %d years old.",name,year);
name = String , year = int

#자료형
byte = 정수형중 가장 작은 범위를 가진 정수형으로써 8bit (256개의 숫자)
short = 2 byte
int = 4byte
long = 8byte

#상속 extends
level2_inheritance package를 참고. 다중상속은 지원하지않는다.(c++에서는 가능) 단 상속계층(상속이 꼬리를 무는느낌)은 가능.
ex) Person 이란 class가 있다면.
    public class Student extends Person --> Person에 있는 것들을 모두 사용가능하다. 또한 다른기능들을 추가가능하다.
    Person class => super class, Student class => sub class;
여기에 추가적으로 아무것도 상속받지않는 class 는 기본적으로 Object를 상속받는다. 여기서 기본적인 class의 기능들을 상속받는다.
결국 모든 class는 상속받는 관계이다.

#Override
상위 클래스에서 제공되는 적용법을 덮어쓰고 싶을때 사용.

#상위클래스에 접근하고싶다면 super. 메서드를 사용하여 접근할수있다.
하위 클래스에서의 생성자에서는 항상 상위클래스의 생성자를 호출한다. [super()을 쓰든 안쓰든 자동적으로 컴파일러에서 적용함]
상위 클래스에서 생성자를 만들게되면 하위 클래스에서는 컴파일러 에러가 뜨는데, 해결하기 위한 방법은 2가지다.
1. public superClass(){}와 public superClass(인자들){} 이렇게 두가지 경우의 생성자를 만든다(인자가 없을경우와 있을경우)
2. 하위 클래스에서 super(필요한 인자); 를 호출하기.///예시는 level2_inheritance package 의 Person(superClass)와 Student(subClass)참고
즉 하위 클래스에서는 무조건 상위클래스의 생성자가 정의되어야한다.

#instanceof 현재 객체가 특정 클래스의 인스턴스인지 알 수 있게 해준다.
ex) Class instanceof Object --> true
    Object instanceof Class --> false

#추상 클래스 AbstractClass
abstract class className{} 으로 class 앞에 abstract를 붙여서 만든다. 추상메서드 = 정의도 없고 형태도 없는 메소드(이름만있음..)
추상 메서드도 abstract public void ade(); 로 선언한다. 여기서 메서드가 하는일이 적혀있지않는데 이것은 어떻게 해결하는가?
-> 추상 클래스를 상속받는 하위 클래스에서 추상 클래스를 다시선언하여 정의와 형태를 만들어준다. ex)AbstractClassCreate pakage 참고
추상 클래스의 인스턴스는 만들어질수없다. 

#인터페이스 Interface
Interface는 추상 클래스처럼 미리 정의도 없고 형태도 없는 메소드를 선언한다. 또한 이 인터페이스를 구현하는 하위클래스는 implements UpperClass 로 선언해야만 한다.
또한 하위클래스에서는 상위클래스에서 선언한 메서드들을 @Override 어노테이션을 사용한채로 다시 재정의 해야한다. ex)InterBasic package 참고
즉 인터페이스에는 일단 구현해야하는 기능들을 간단하게 사용할 임시구현클래스를 만들고 사용하다가 진짜 사용해야할때 제대로된 구현 클래스를 만들어서
사용해야 할때 유용하다.[실제로 사용 가능하지 않더라도 작업을 계속할수있게끔 하거나 Test코드에서 유용할듯 싶다.
(가장 큰 특징은 코드변경을 최소화 하면서 동작하는 방식을 변경해줄수있다. Spring에서 사용하는걸 본적있음.)
인터페이스는 인터페이스를 extends 할수있다. 단 인터페이스를 연장시킨 인터페이스2를 구현(implement)하기 위해서는 인터페이스 1과 인터페이스2의
추상메서드 들을 구현해야한다. 여기서 인터페이스2에 해당하는 메서드들만 구현해서 사용하고 싶다면 추상클래스를 구현클래스로써 사용하면된다.
추상클래스에서는 인터페이스에 선언되어있는 메서드들의 일부만 구현할 수 있도록 허용되어있다. (근데 이 추상클래스를 구현하는 클래스는 죄다 구현해야함..)
인터페이스에서는 변수는 선언할수없고(int test;) 상수는 선언할수있다.(int test =5;)
추상적인 메서드를 선언하는것 뿐만 아니라 구현까지 마친 일반적인 메서드들을 만들수도있다.(Java 8에서 허용된..)

#추상클래스와 인터페이스 차이?
추상클래스와 인터페이스는 하는일이 비슷해 보이나 존재목적이 좀 다르다고 할수있다.
아니, 추상적으로 메서드들을 적어놓고 하위클래스에 구현(@Override)을 맡기는 부분이 아주 하는일이 같아보이는데 뭐가 다른걸까?
일단 추상클래스는 일부분만 구현해도 일단은 돌아가는데, 인터페이스의 경우에는 모두 구현해야 동작한다.
또한 추상클래스는 다중상속이 불가능한데, 인터페이스의 경우에는 다중상속이 가능하다.(그만큼 구현도 다해줘야한다)
추상클래스는 상속에 대한 계층구조를 명확하게하고, 일반변수들과 일반 메서드들을 사용가능하며 구현하지 않아도 될 메서드는 냅둬도 괜찮다.
인터페이스는 디자인(내부적으로 동작하는 부분)이 자주 바뀌거나 메서드 형태만 서로 공유해서 구현되는 상황일 떄 적합하다.
인터페이스가 자주 사용되는이유는 동시개발이 가능하다는 점 때문이다(대충만든 구현클래스만 만들어도 동작이 가능하기떄문)
추상 클래스 = 관련선이 높은 클래스들 간에 코드를 공유하고싶은경우 (상속 관계),추상 클래스를 상속 받을 클래스들이 공통으로 가지는 메소드와
필드가 많거나 public 이외의 접근제어자가 필요한경우.
인터페이스  = 서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는경우(비슷한 동작을 하는 메서드가 필요한경우)
특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동들이 구현되는지 신경쓰지 않아도 되는경우, 다중상속을 허용하고 싶은경우.
//InterBasic 의 FlyRunner 와 AbstractClassCreate 의 AnimalRunner 참고할것.
//참고 https://velog.io/@new_wisdom/Java-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4

#객체 생성?
자바에서 객체를 생성할 때 선언하는 기준은 해당 클래스의 생성자를 호출하고, 반환된 인스턴스를 변수에 할당하는 방식이다.
ex) Person person = new Person("Alice",24); 이라고 한다면 new Person("Alice", 24) 는 Person클래스의 생성자를 호출하고
"Alice"와 24를 인자로써 전달하여 Person객체를 생성한다. 그리고 이 객체를 person 변수에 할당한다.

#접근제어자 private public default protected
public => 접근에 제한이 없음
protected => 동일한 패키지 내에 존재하거나 파생클래스에서만 접근 가능
default => 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근이 가능
private => 자기 자신의 클래스 내에서만 접근이 가능
접근 범위의 크기순 public > protected > default > private

#프로그래머가 알아야할 97가지
https://choiwy.tistory.com/477

#다형성
같은 코드로 동작하는데 다른 방식으로 결과가 나온다.=> 추상클래스 ( 각 객체의 참조값에 따라 변화한다)

#불변성과 가변성
문자열, BigDecimal, Wrapper 등은 인스턴스를 만든 순간부터 값을 변경할수없다. 만일 List를 가변성 배열로써 사용하고싶다면
ArrayList, LinkedList, Vector 등을 사용해야한다. 이미 만들어진 List의 원소들로 ArrayList를 만들려면 어떻게해야할까?
-> List<String> ArrayListTest = new ArrayList<>(List); -> List<String> LinkedListTest = new LinkedList<>(List);
이러한 ArrayList등은 원소를 추가할수있다.

#집합 Collections (Java 9 부터 지원)
1.List 2.Set 3.Queue 4.Map 5.Tree 6.LinkedList
1-1)초기화방법 List<String> words = List.of("Apple","Bat","Cat");
1-2)자주 사용되는 메서드 size() = list크기 반환, isEmpty() = 비어있는지 확인, get(n) = n번째 인덱스 의 원소 반환,
 contatins(A) = A라는 원소가 있는지 boolean 으로 반환, indexof(A) = A라는 원소가 몇번째 원소에 있는지 반환,존재하지않을경우 -1 반환

#ArrayList 배열
가변리스트이다 .add()메서드, .remove()메서드로 삽입또는 지울수있다. 자세한건 검색.
선언하는 건 ArrayList items = new ArrayList(); 로 할수있는데, 여기서 제네릭(자바5에서 나온 기능)을 사용해야한다.
즉 어떤 자료형을 ArrayList에 담을건지 명시해야한다는 뜻이다. ex) ArrayList<String> items = new ArrayList<String>();
일반 Array와는 메서드도 다르므로 주의

#LinkedList
한요소에서 다른요소로의 참조가 들어있는 방식의 배열. 어떠한 원소하나에 접근하는것은 느릴수있으나 배열의 일부분을 변경할경우에는 빠른속도를 보장한다.
ArrayList와 Vector는 기본적으로 Array방식으로 동작하지만, LinkedList는 자신만의 방식이있다. LinkedList의 특정원소는 자기 앞과 뒤의 원소로 갈수있다.
즉 ArrayList와 Vector는 원소의 변경에는 시간이 많이들지만 특정원소에 접근하는것은 빠르다.
LinkedList는 원소의 변경에는 시간이 빠르지만 특정원소에 접근하는것은 느리다.

#Vector
여러 쓰레드가 동작하고있을경우 Vector는 거의 모든 메서드들이 Synchronized(동기화) 되어있기때문에 안전하다.
가장 기본적인 동기화를 제공한다.ArrayList는 Thread Safe를 보장하지않는다.

#iterator 객체.
생성방법 => Iterator<데이터 타입> iterator이름 = 컬렉션.iterator();
Iterator는 모든 Collections 프레임워크에서 공통으로 사용가능하고, 쉽게 값을 가져오고 제거할수있으며, 주요3가지 메서드만 알면 사용하기쉽다.
Iterator.hasNext() = Iterator안에 다음값이 들어있는지 확인 bool로 반환, Iterator.next() => Iterator의 다음값 가져오기
Iterator.remove() = Iterator에서 next()로 가져온 값을 컬렉션에서 삭제. 반드시 next()다음에 사용해야한다.
Iterator는 처음부터 끝까지 단방향으로만 반복이 가능하고, 값을 변경 및 추가가 불가능하며, 대량의 데이터를 제어할때 속도가 느리다.
예시 사용방식 ex) Iterator wordsIterator = wordArrayList.iterator();
                    while(wordsIterator.hasNext()){
                        System.out.println(wordsIterator.next());
                    }                   CollectionsBasic package의 CollectionArrayList 참고.


